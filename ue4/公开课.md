
# 多线程API渲染

rhi线程 在移动平台10% - 20%的提升 帧率更加稳定

游戏线程
渲染线程
设备线程
物理线程
动画线程

# 剔除

如果渲染比较慢，可能会有错帧的情况

1 距离剔除 摄像机到物理之间的距离 - volume
2 视锥剔除 人眼的视角锥体外的东西不渲染 binding box 判断相交
3 潜在可见集 PVS  一个大体积的表面  需要预处理 格子。推荐在城市场景 室内的场景才使用，避免一次处理太多格子
4 遮挡踢除 
   硬件查询 整个场景都绘制一遍 drawcall翻倍 大部分不是正优化 提供1个思路 延迟3帧来解决 减少阻塞，相机快速移动会掉帧
   GPU中并行 HZB - 就是把 深度 copy 1份 以及深度值 对 要被剔除的问题 进行查询 binding box 映射到 hzb的层级上，越大的物体分辨率不需要那么大，对近距离的就更精细 射线碰撞
UNREAL 是通过 computer shader中做 过程中 东西发给 cpu处理 有阻塞有几毫米的损耗

5 软件剔除 专门是给移动平台的 在CPU的时候就做了 CPU也可以并行 效率很高
6 空间剔除 四叉树 普通MMO 八叉树 飞行游戏 3d四叉树

顺序：
消耗最少 消耗第二少的 -> 消耗最大的

# 绘制 几何 画3角形

Early-Z

绘制的时候 对 pixel 进行排序
有可能会 over draw
颜值方面，颜值管线

移动平台 rofa 当成不透明的物理来画 解决移动端GPU overdraw的问题 Early-Z-path mash only 提升帧率与发热


几何绘制
    drawcall会性能损耗 阻塞/提交等待提交等待 渲染 100W个面 与 100个1W的面
    1个模型有几个drawcakk
    world position offset
    屏蔽远处顶点动画，设置远处的更新频率


几何优化
    merge mesh 同1个材质复用同样的纹理 就可以公用1次draw call
    GPU Scene 所有的草 用1个draw call 支持自定义传输给GPU的数据 ，红草，绿草， 移动端是 Image buffer 有大小限制
    HLOD 
       解决大世界的问题 分区或某个原则把里面所以的东西拉进来 mesh合成1个 贴图也合成1个
       overShading 多次重绘 1个像素被弄了很多次，因为透明重叠
         
GBuffer 延迟管线
   优势 稳定 光源数量不敏感 与屏幕分辨率敏感，因为多光源情况下也会多次渲染
   劣势 带宽高 透明
   移动平台实现 抓帧

纹理材质
   贴图大小 压缩方式 ASTC
   shader复杂度
   显示面积
直接光
  GGX
  IES/Light func 投射光 水波的反光
  阴影
    CSM 层级分辨率
    POS 静态ligtmap与动态结合，不能变方向
    DFS 距离场 标识物体内外信息 3d Teture 2个纹理合并  远处的阴影，内存不够，精度也不够
    CS
间接光
   光照贴图 
    light map烘培 
    ILC 动态物体的明暗关系，对大物体不友好
    VLM/LPPV 体积light map 用像素去混合角色的光照
   阴影 
     DFAO 距离场 小阴影
     GTAO 由HBAO衍生而来，精度更高 normal重建
     Capsule Shadows 不用几何体做阴影，用人体的胶囊来做
   反射
      Sence Capture    不是那么精确，水面反射，  再来1个摄像机 再来1次?
      屏幕空间反射 SSR  remachanin 屏幕外的东西没办法反射  -> SSPR, 天刀 copy1个另外的RT结合在IBL上
      平面反射          
      其他



# 光栅 铺砖

雾
   高度雾 - 体积雾
   3d texture 去处理 在PC上用
   移动平台就挂了 remachanin（基于前面的帧，不断积累前面的帧数，通过查词和降噪来实现 N帧混合来做） 8个步，分辨率也不是太高 应该还好
   
后期特效
   步骤其实还行
   


