# 图形渲染

#### 1 DX 与 OpenGL 分别是什么

中间层 软件 硬件 中间 适配硬件的API

+ DX 很多API  
    + 效率高
    + 新特性多

+ OpenGL 图形API 跨平台的
    + 安卓和IOS 阉割版 openGL ES
    + 效率低 新特性少

#### 2 DX12 效率至上 更好的利用多核CPU

+ 底层API 开发者更加接近底层硬件
+ 减少API减少CPU开销
+ 支持更多draw call


#### 3 性能倒退? 自由!=繁荣 DX12游戏表现


#### 4 Vulkan 与 DX12

Vulkan 也是类似 DX12 的底层API

#### 5 定制化

+ 本世代
    + CPU的计算丢给GPU -> 通用计算

+ PS4
   + GNM  底层
   + GNMX 高层级  方便跨平台游戏移植 DX11 ， 开发者的最终选择


#### 6 什么是3d?

+ 2D+透视 = 3D ?

+ `光栅化：实际绘制或填充每个顶点之间的 像素形成过程`

光栅化计算：
显示器实际显示的图像是由像素组成的，
我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。
把一个  矢量图形  转换为一系列  像素点  的过程就称为光栅化。
例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。

最终输出：
由ROP（光栅化引擎）最终完成像素的输出，
1帧渲染完毕后，被送到显存帧缓冲区(显存)

一个支持OpenGL渲染的窗口 (即帧缓存 显存) 可能包含以下的组合：
· 至多4个颜色缓存

· 一个深度缓存 ?

· 一个模板缓存 ?

· 一个积累缓存 ?

· 一个多重采样缓存 ?


#### 7 GPU 组成原理

计算单元
控制器
寄存器

具有高并行结构（highly parallel structure），所以GPU在处理图形数据和复杂算法方面拥有比CPU更高的效率

GPU拥有更多的ALU（Arithmetic Logic Unit，逻辑运算单元）用于数据处理

而非数据高速缓存和流控制，这样的结构适合对密集型数据进行并行处理

CPU执行计算任务时，一个时刻只处理一个数据，不存在真正意义上的并行，而GPU具有多个处理器核，在一个时刻可以并行处理多个数据

并行计算 
多个数据可以同时被使用，多个数据并行运算的时间和1个数据单独执行的时间是一样的


GPU采用流式并行计算模式
可对每个数据进行独立的并行计算
如：
计算一个顶点的世界位置坐标，不依赖于其他顶点的位置

GPU 完成3D图形的生成 将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出

#### 8 CPU 与 GPU 的分工

光影生成的轮廓都是CPU计算的，
光影生成的颜色都是GPU计算的，

GPU只有2个工作，
1多边形生成。
2为多边形上颜色

#### 8 整个过程

CPU从硬盘中读取模型，

CPU分类后将多边形信息交给GPU，

GPU再实时处理成屏幕上可见的多边形，但是 没有纹理 只有线框。

CPU计算出模型后，GPU将模型数据放进显存，
显卡同时也为模型贴材质，给模型上颜色。

CPU相应从显存中获取多边形的信息。
然后CPU计算光照后产生的影子的轮廓。等CPU计算出后，

显卡的工作又有了，那就是为影子中填充深的颜色。

周而复始，完成CPU与GPU之间的数据交换


#### 9 openGL 存在的必要性

数据饥饿:从一块内存中将数据复制到另一块内存中，
传递速度是非常慢的，
内存复制数据时，
CPU和GPU都不能操作数据(避免引起错误)


#### 10 着色器

图元
组成图像的基本单元(OpenGL中有7种基本几何图元)，它只是顶点的集合以预定义的方式结合在一起而已

OpenGL渲染管线（rendering pipeline）：
一系列有序的处理阶段的序列，用于把我们应用程序中的 数据 转化为 生成一个最终的图像 的一个过程

+ 1 CPU提供数据 GPU接收用户提供的几何数据(顶点和几何图元),并且将它输入到一系列着色器阶段中进行处理 （包括顶点着色、细分着色（它本身包含两个着色器）以及最后的几何着色）
+ 2 图元装配和剪切后，将它们送到光栅化单元(rasterizer)
+ 3 光栅化单元负责对所有剪切区域(clipping region)内的图元生成 片元数据
+ 4 然后对每个生成的片元都执行一个片元着色器


.GLSL:
专门为图形开发设计的编程语言



#### 11 着色器说明

细分着色器：

顶点着色器处理每个顶点的关联数据之后，
如果同时激活了细分着色器(tessellation shader)，那么它讲进一步处理这些数据。
细分着色器会使用面片（patch）来描述一个物体的形状，
并且使用相对简单的面片几何体连接来完成细分的工作，其结果是几何图元的数量增加，
并且模型的外观变得更加平顺。细分着色阶段会用到两个着色器来分别 管理面片数据 并 生产最终的形状

几何着色器
允许在光栅化之前对每个几何图元做更进一步的处理

图元装配
图元装配将顶点与几何图元之间组织起来，准备下一步的剪切和光栅化工作

剪切
顶点可能落在视口(viewport)之外，此时与顶点相关的图元会做出改动，以保障相关的像素不会再视口外绘制

光栅化
剪切之后马上要执行的工作，就是讲更新后的图元 传递到光栅化(rasterizer)单元
，生成对应的片元。
光栅化的工作是判断某一部分几何体（点、线、三角形）所覆盖的屏幕空间。
得到了屏幕空间信息以及输入的顶点数据之后，
光栅化单元就可以直接对片元着色器中的每个可变变量进行线性插值，
然后将结果传递给用户的片元着色器。
光栅化意味着一个片元的声明伊始，
而片元着色器 中的计算过程本质上意味着计算这个片元的最终颜色，它决不等价于OpenGL对这个片元所执行的全部操作

片元着色器：
最后一个可以通过编程控制显示颜色的阶段。
片元着色器计算 片元的最终颜色（尽管在逐片元操作中可能还会最终改变一次颜色）和它的深度值。
片元着色器会使用纹理映射的方式，对顶点处理阶段所计算的颜色纸进行补充。
如果我们觉得不应该继续绘制某个片元，在片元着色器中还可以终止这个片元的处理，这一步叫做片元的丢弃(discard)。
总之，顶点着色(包括细分着色和几何着色)决定了一个图元应该位于屏幕的什么位置，而片元着色使用这些信息来决定某个片元的颜色应该是什么

逐片元的操作：
除了在片元着色器中做的工作之外，
片元 操作的下一步就是最后的独立片元处理过程。
这个阶段里会使用 深度测试(depth test) 和 模板测试(stencil test) 的方式来 决定一个片元是否是可见的。
如果一个片元通过了所有的测试，那么它就可以被直接绘制到帧缓存中了，
它对应的像素的颜色值(也可能包括深度z值)会被更新，
如果开启了混合(blending)模式，那么片元的颜色会与该像素当前的颜色相叠加，
形成一个新的颜色值并写入帧缓存中
